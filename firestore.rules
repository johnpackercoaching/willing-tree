rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function isPartnerInInnermost(innermostId) {
      let innermost = get(/databases/$(database)/documents/innermosts/$(innermostId)).data;
      return isAuthenticated() && (
        request.auth.uid == innermost.partnerA ||
        request.auth.uid == innermost.partnerB
      );
    }

    function isParticipantInBox(boxId) {
      let box = get(/databases/$(database)/documents/willingBoxes/$(boxId)).data;
      return isAuthenticated() && (
        request.auth.uid in box.participants
      );
    }

    function hasValidUserFields() {
      let data = request.resource.data;
      return data.keys().hasAll(['email', 'displayName', 'createdAt']);
    }

    function hasValidInnermostFields() {
      let data = request.resource.data;
      return data.keys().hasAll(['partnerA', 'partnerB', 'createdAt']) &&
        data.partnerA is string &&
        data.partnerB is string &&
        data.partnerA != data.partnerB;
    }

    // Rate limiting helper (basic implementation)
    function rateLimitNotExceeded() {
      // In production, you'd want to track this in a separate collection
      return true;
    }

    // Users collection - only owner can read/update their profile
    match /users/{userId} {
      allow read: if isOwner(userId) ||
        // Allow reading public profile info for connections
        (isAuthenticated() && exists(/databases/$(database)/documents/innermosts/$(request.auth.uid + '_' + userId)) ||
         exists(/databases/$(database)/documents/innermosts/$(userId + '_' + request.auth.uid)));
      allow create: if isOwner(userId) && hasValidUserFields();
      allow update: if isOwner(userId) && hasValidUserFields();
      allow delete: if false; // Never allow deletion
    }

    // Innermosts collection - only partners can access
    match /innermosts/{innermostId} {
      allow read: if isPartnerInInnermost(innermostId);
      allow create: if isAuthenticated() &&
        hasValidInnermostFields() &&
        (request.resource.data.partnerA == request.auth.uid ||
         request.resource.data.partnerB == request.auth.uid) &&
        rateLimitNotExceeded();
      allow update: if isPartnerInInnermost(innermostId) &&
        // Prevent changing partners after creation
        request.resource.data.partnerA == resource.data.partnerA &&
        request.resource.data.partnerB == resource.data.partnerB;
      allow delete: if false; // Soft delete only via update
    }

    // WillingBoxes collection - only participants can access
    match /willingBoxes/{boxId} {
      allow read: if isParticipantInBox(boxId);
      allow create: if isAuthenticated() &&
        request.auth.uid in request.resource.data.participants &&
        request.resource.data.participants.size() <= 2 &&
        rateLimitNotExceeded();
      allow update: if isParticipantInBox(boxId) &&
        // Prevent changing participants after creation
        request.resource.data.participants == resource.data.participants;
      allow delete: if false;
    }

    // PairingInvitations collection - secure invitation flow
    match /pairingInvitations/{inviteId} {
      allow read: if isAuthenticated() && (
        // Creator can read their own invitations
        resource.data.createdBy == request.auth.uid ||
        // Invitee can read invitations sent to them
        resource.data.inviteeEmail == request.auth.token.email
      );
      allow create: if isAuthenticated() &&
        request.resource.data.createdBy == request.auth.uid &&
        request.resource.data.createdAt == request.time &&
        rateLimitNotExceeded();
      allow update: if isAuthenticated() &&
        // Only invitee can accept
        resource.data.inviteeEmail == request.auth.token.email &&
        // Can only change status and acceptedAt
        request.resource.data.createdBy == resource.data.createdBy &&
        request.resource.data.inviteeEmail == resource.data.inviteeEmail;
      allow delete: if isAuthenticated() &&
        resource.data.createdBy == request.auth.uid;
    }

    // EmailQueue collection - write-only for users
    match /emailQueue/{emailId} {
      allow create: if isAuthenticated() &&
        request.resource.data.requestedBy == request.auth.uid &&
        rateLimitNotExceeded();
      allow read: if false;
      allow update: if false;
      allow delete: if false;
    }

    // SmsQueue collection - write-only for users
    match /smsQueue/{smsId} {
      allow create: if isAuthenticated() &&
        request.resource.data.requestedBy == request.auth.uid &&
        rateLimitNotExceeded();
      allow read: if false;
      allow update: if false;
      allow delete: if false;
    }

    // Weekly cycles subcollection under innermosts
    match /innermosts/{innermostId}/weeklyCycles/{cycleId} {
      allow read: if isPartnerInInnermost(innermostId);
      allow create: if false; // Only cloud functions can create
      allow update: if isPartnerInInnermost(innermostId) &&
        // Can only update their own responses
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['partnerAResponse', 'partnerBResponse']));
      allow delete: if false;
    }

    // Wishlists subcollection under users
    match /users/{userId}/wishlists/{wishlistId} {
      allow read: if isOwner(userId) || isPartnerInInnermost(userId + '_' + request.auth.uid);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }
  }
}